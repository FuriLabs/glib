From: =?utf-8?b?Ik1hcmNvIFRyZXZpc2FuIChUcmV2acOxbyki?= <mail@3v1n0.net>
Date: Fri, 10 May 2024 01:17:15 +0200
Subject: glib/tests/mapping: Check the exit status of the child process

In this way if it fails for some memory error we can track it

Origin: upstream, 2.80.3, commit:116312f089a2142fc8a20353543d805f01085458
---
 glib/tests/mapping.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/glib/tests/mapping.c b/glib/tests/mapping.c
index 99cb8ee..5fcde83 100644
--- a/glib/tests/mapping.c
+++ b/glib/tests/mapping.c
@@ -22,6 +22,7 @@
 
 #ifdef G_OS_UNIX
 #include <unistd.h>
+#include <sys/wait.h>
 #endif
 #ifdef G_OS_WIN32
 #include <process.h>
@@ -201,8 +202,10 @@ test_child_private (void)
   gsize len;
   gchar *child_argv[4];
   GPid  child_pid;
+  GSpawnFlags spawn_flags = G_SPAWN_DEFAULT;
 #ifndef G_OS_WIN32
   GMainLoop *loop;
+  int wait_status;
 #endif
   gchar pid[100];
   gchar *dir, *global_filename, *childname;
@@ -221,6 +224,7 @@ test_child_private (void)
 
 #ifndef G_OS_WIN32
   signal (SIGUSR1, handle_usr1);
+  spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;
 #endif
 
   g_snprintf (pid, sizeof(pid), "%d", getpid ());
@@ -230,7 +234,7 @@ test_child_private (void)
   child_argv[3] = NULL;
 
   result = g_spawn_async (dir, child_argv, NULL,
-                          0, NULL, NULL, &child_pid, &error);
+                          spawn_flags, NULL, NULL, &child_pid, &error);
   g_assert_no_error (error);
   g_assert_true (result);
   g_test_message ("test_child_private: child spawned");
@@ -261,6 +265,10 @@ test_child_private (void)
 #ifndef G_OS_WIN32
   g_idle_add (check_stop, loop);
   g_main_loop_run (loop);
+  waitpid (child_pid, &wait_status, 0);
+  g_test_message ("Child exited with status %d", wait_status);
+  g_spawn_check_wait_status (wait_status, &error);
+  g_assert_no_error (error);
 #else
   g_usleep (2000000);
 #endif
