From: Philip Withnall <pwithnall@endlessos.org>
Date: Fri, 19 Feb 2021 18:09:42 +0000
Subject: =?utf-8?q?tests=3A_Test_g=5Fsubprocess=5Flauncher=5Fclose=28=29_do?=
 =?utf-8?q?esn=E2=80=99t_close_too_many_FDs?=
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

Expand an existing unit test to check that the target FD of a
`g_subprocess_launcher_take_fd()` call doesn’t get closed when
`g_subprocess_launcher_close()` is called. Only the source FD should be
closed by the parent process.

Signed-off-by: Philip Withnall <pwithnall@endlessos.org>

Helps: #2332

Origin: https://gitlab.gnome.org/GNOME/glib/-/commit/50cf90dc
---
 gio/tests/gsubprocess.c | 27 ++++++++++++++++++++++++---
 1 file changed, 24 insertions(+), 3 deletions(-)

diff --git a/gio/tests/gsubprocess.c b/gio/tests/gsubprocess.c
index 3c248e6..7e22678 100644
--- a/gio/tests/gsubprocess.c
+++ b/gio/tests/gsubprocess.c
@@ -1494,23 +1494,44 @@ test_subprocess_launcher_close (void)
   GSubprocessLauncher *launcher;
   GSubprocess *proc;
   GPtrArray *args;
-  int fd;
+  int fd, fd2;
   gboolean is_open;
 
-  fd = dup(0);
+  /* Open two arbitrary FDs. One of them, @fd, will be transferred to the
+   * launcher, and the other’s FD integer will be used as its target FD, giving
+   * the mapping `fd → fd2` if a child process were to be spawned.
+   *
+   * The launcher will then be closed, which should close @fd but *not* @fd2,
+   * as the value of @fd2 is only valid as an FD in a child process. (A child
+   * process is not actually spawned in this test.)
+   */
+  fd = dup (0);
+  fd2 = dup (0);
   launcher = g_subprocess_launcher_new (G_SUBPROCESS_FLAGS_NONE);
-  g_subprocess_launcher_take_fd (launcher, fd, fd);
+  g_subprocess_launcher_take_fd (launcher, fd, fd2);
+
   is_open = fcntl (fd, F_GETFD) != -1;
   g_assert_true (is_open);
+  is_open = fcntl (fd2, F_GETFD) != -1;
+  g_assert_true (is_open);
+
   g_subprocess_launcher_close (launcher);
+
   is_open = fcntl (fd, F_GETFD) != -1;
   g_assert_false (is_open);
+  is_open = fcntl (fd2, F_GETFD) != -1;
+  g_assert_true (is_open);
+
+  /* Now test that actually trying to spawn the child gives %G_IO_ERROR_CLOSED,
+   * as g_subprocess_launcher_close() has been called. */
   args = get_test_subprocess_args ("cat", NULL);
   proc = g_subprocess_launcher_spawnv (launcher, (const gchar * const *) args->pdata, error);
   g_ptr_array_free (args, TRUE);
   g_assert_null (proc);
   g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_CLOSED);
   g_clear_error (error);
+
+  close (fd2);
   g_object_unref (launcher);
 }
 
