From 63c4de7737b1a686b1be075fbae83b4e7d437c4d Mon Sep 17 00:00:00 2001
From: Ryan Lortie <desrt@desrt.ca>
Date: Fri, 9 Sep 2011 21:40:05 -0400
Subject: [PATCH] gmain: get rid of poll_waiting

This variable, which is the cause of much grief, exists for two reasons:

  - ensuring the the wakeup pipe doesn't fill up

  - preventing the first poll() after adding a source from waking up
    immediately

The first point is no longer an issue with GWakeup.

The second point is addressed by using different logic: we only signal a
wakeup in the case that the context is currently acquired by a thread
that is not us.

As an added bonus, we can now implement g_main_context_wakeup() without
taking a lock.

https://bugzilla.gnome.org/show_bug.cgi?id=583511
https://bugzilla.gnome.org/show_bug.cgi?id=320888

Conflicts:

	glib/gmain.c
---
 glib/gmain.c |   65 +++++++++++++++++----------------------------------------
 1 files changed, 20 insertions(+), 45 deletions(-)

diff --git a/glib/gmain.c b/glib/gmain.c
index 6662a09..481f0e4 100644
--- a/glib/gmain.c
+++ b/glib/gmain.c
@@ -241,7 +241,6 @@ struct _GMainContext
   GWakeup *wakeup;
 
   GPollFD wake_up_rec;
-  gboolean poll_waiting;
 
 /* Flag indicating whether the set of fd's changed during a poll */
   gboolean poll_changed;
@@ -356,7 +355,6 @@ static void g_main_context_add_poll_unlocked    (GMainContext *context,
 						 GPollFD      *fd);
 static void g_main_context_remove_poll_unlocked (GMainContext *context,
 						 GPollFD      *fd);
-static void g_main_context_wakeup_unlocked      (GMainContext *context);
 
 static void _g_main_wake_up_all_contexts        (void);
 
@@ -956,8 +954,11 @@ g_source_attach (GSource      *source,
   result = g_source_attach_unlocked (source, context);
 
 #ifdef G_THREADS_ENABLED
-  /* Now wake up the main loop if it is waiting in the poll() */
-  g_main_context_wakeup_unlocked (context);
+  /* If another thread has acquired the context, wake it up since it
+   * might be in poll() right now.
+   */
+  if (context->owner && context->owner != G_THREAD_SELF)
+    g_wakeup_signal (context->wakeup);
 #endif
 
   UNLOCK_CONTEXT (context);
@@ -2700,17 +2701,6 @@ g_main_context_prepare (GMainContext *context,
       return FALSE;
     }
 
-#ifdef G_THREADS_ENABLED
-  if (context->poll_waiting)
-    {
-      g_warning("g_main_context_prepare(): main loop already active in another thread");
-      UNLOCK_CONTEXT (context);
-      return FALSE;
-    }
-  
-  context->poll_waiting = TRUE;
-#endif /* G_THREADS_ENABLED */
-
 #if 0
   /* If recursing, finish up current dispatch, before starting over */
   if (context->pending_dispatches)
@@ -2908,12 +2898,9 @@ g_main_context_check (GMainContext *context,
     }
   
 #ifdef G_THREADS_ENABLED
-  if (!context->poll_waiting)
+  if (context->wake_up_rec.events)
     g_wakeup_acknowledge (context->wakeup);
 
-  else
-    context->poll_waiting = FALSE;
-
   /* If the set of poll file descriptors changed, bail out
    * and let the main loop rerun
    */
@@ -3323,9 +3310,11 @@ g_main_loop_quit (GMainLoop *loop)
 
   LOCK_CONTEXT (loop->context);
   loop->is_running = FALSE;
-  g_main_context_wakeup_unlocked (loop->context);
 
 #ifdef G_THREADS_ENABLED
+  if (g_thread_supported ())
+    g_wakeup_signal (loop->context->wakeup);
+
   if (loop->context->cond)
     g_cond_broadcast (loop->context->cond);
 #endif /* G_THREADS_ENABLED */
@@ -3527,7 +3516,8 @@ g_main_context_add_poll_unlocked (GMainContext *context,
   context->poll_changed = TRUE;
 
   /* Now wake up the main loop if it is waiting in the poll() */
-  g_main_context_wakeup_unlocked (context);
+  if (g_thread_supported ())
+    g_wakeup_signal (context->wakeup);
 #endif
 }
 
@@ -3591,7 +3581,8 @@ g_main_context_remove_poll_unlocked (GMainContext *context,
   context->poll_changed = TRUE;
   
   /* Now wake up the main loop if it is waiting in the poll() */
-  g_main_context_wakeup_unlocked (context);
+  if (g_thread_supported ())
+    g_wakeup_signal (context->wakeup);
 #endif
 }
 
@@ -3741,28 +3732,11 @@ _g_main_wake_up_all_contexts (void)
     {
       GMainContext *context = list->data;
 
-      LOCK_CONTEXT (context);
-      g_main_context_wakeup_unlocked (context);
-      UNLOCK_CONTEXT (context);
+      if (g_thread_supported ())
+        g_wakeup_signal (context->wakeup);
     }
   G_UNLOCK (main_context_list);
 }
-
-
-/* HOLDS: context's lock */
-/* Wake the main loop up from a poll() */
-static void
-g_main_context_wakeup_unlocked (GMainContext *context)
-{
-#ifdef G_THREADS_ENABLED
-  if (g_thread_supported() && context->poll_waiting)
-    {
-      context->poll_waiting = FALSE;
-      g_wakeup_signal (context->wakeup);
-    }
-#endif
-}
-
 /**
  * g_main_context_wakeup:
  * @context: a #GMainContext
@@ -3775,12 +3749,13 @@ g_main_context_wakeup (GMainContext *context)
 {
   if (!context)
     context = g_main_context_default ();
-  
+
   g_return_if_fail (g_atomic_int_get (&context->ref_count) > 0);
 
-  LOCK_CONTEXT (context);
-  g_main_context_wakeup_unlocked (context);
-  UNLOCK_CONTEXT (context);
+#ifdef G_THREADS_ENABLED
+  if (g_thread_supported())
+    g_wakeup_signal (context->wakeup);
+#endif
 }
 
 /**
-- 
1.7.7.2

